# 计算机体系结构课后习题

## 第一章

1.略

2.假设计算机执行一条一级指令需要$t$时间，那么对于一条$r$级指令来说，他会被解释成$N^{r-1}$条一级指令，完成$M^{r-1}$条一级指令，则$r$级指令完成一条一级指令所用的平均时间为$\frac{N^{r-1}}{M^{r-1}}t$。则对于一段在第一级上执行需要$K$时间的程序来说，在第二、三、四级上执行需要的时间为$\frac{N}{M}K$、$\frac{N^2}{M^2}K$、$\frac{N^3}{M^3}K$。

3.主要特征：以运算器为中心、采用存储程序原理、存储器是按地址访问的、控制流由指令流产生、指令由操作码和地址码组成、数据以二进制编码表示。

存在问题：CPU和存储器、I/O设备之间的速度存在越来越大的差距，严重影响了处理器性能的发挥。

如何改进：前瞻、多线程、流水线、路径缓冲、向量部件、SIDM加速、GPU异构计算，等等。

4.有效CPI=$\frac{660}{259}$，MIPS=$\frac{5180}{33}$，程序执行时间T=535$\mu s$

5.（1）$S_p=\frac{S_f}{0.9S_f+0.1}$

![1700402097181](images/1700402097181.png)

（2）最大为$\frac{10}{9}$

6.（1）设加速比为$S$，可向量化百分比为$P$，则$S=\frac{20}{20-19P}$

（2）

![1700402334082](images/1700402334082.png)

7.（1）设原来系统执行时间为$100T$，部件3可改进比例为$x$，则改进后系统执行时间为$(41.5-90x)T$，加速比为$\frac{100}{41.5-90x}$，加速比为10时，$x=15\%$

（2）设原来系统执行时间为$100T$，则不可改进部分执行时间为$20T$，改进后系统执行时间为$23.5T$，占比为$84.998\%$

（3）占比为$70\%$的，占比为$70\%$和任一占比为$20\%$的。

8.（1）操作1：$2$，操作2：$\frac{4}{3}$，操作3：$\frac{10}{3}$，操作4：$4$

（2）操作1：$1.000005000025$，操作2：$1.0000075000562503$，操作3：$1.0000245006002646$，操作4：$1.0000112501265639$

（3）$1.0000895905257434$

9.略

## 第二章

1.略

2.CPU中用来存放操作数的存储单元。

* 堆栈型结构
* 累加器型结构
* 寄存器型结构
* 寄存器访问比存储器快很多
* 对编译器而言，能更加容易、有效分配和使用寄存器。在表达式求值方面，通用寄存器型结构具有更大的灵活性和更高的效率

![1700466815358](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700466815358.png)

(1) 指令集功能设计：主要有RISC和CISC两种技术发展方向； (2) 寻址方式的设计：设置寻址方式可以通过对基准程序进行测试统计，察看各种寻址方式的使用频率，根据适用频率设置必要的寻址方式。 (3) 操作数表示和操作数类型：主要的操作数类型和操作数表示的选择有：浮点数据类型、整型数据类型、字符型、十进制数据类型等等。 (4) 寻址方式的表示：可以将寻址方式编码于操作码中，也可以将寻址方式作为一个单独的域来表示。 (5) 指令集格式的设计：有变长编码格式、固定长度编码格式和混合型编码格式3种。

可以显著减少程序的指令条数，但同时也可能增加计算机的实现复杂度和指令的平均执行周期数。

- 将寻址方式编码与操作码中，由操作码描述相应操作的寻址方式。
  - 适合：采用 load-store 结构的处理机，寻址方式只有很少几种。
- 在指令字中设置专门的寻址字段，直接指出寻址方式。
  - 灵活，操作码短，但需要设置专门的寻址方式字段，而且操作码和寻址方式字段合起来所需要的总位数可能会比隐含方法的总位数多。
  - 适合：有多种寻址方式的处理机，且指令有多个操作数

规整性：主要包括对称性和均匀性。

- 对称性：所有与指令系统有关的存储单元的使用、操作码的设置等都是对称的。
- 均匀性：指对于各种不同的操作数类型、字长、操作种类和数据存储单元，指令的设置都要同等对待。

* 等长操作码：在早期的计算机上，为了便于分级译码，一般采用等长操作码
* 定长操作码：为了保证操作码的译码速度，减少译码复杂度。

10.![1700467335270](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700467335270.png)![1700467344542](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700467344542.png)![1700467358347](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700467358347.png)

除了数据表示之外的所有数据类型都是数据结构要研究的内容。

计算机硬件能直接识别、指令系统可以直接调用。

$T_{CPU}=CPI\times IC\times T_{CLK}$

相同功能的CISC目标程序的指令条数IC 少于RISC的IC，但是CISC的CPI和T都大于RISC的CPI和T，因此，CISC目标程序的执行时间比RISC的更长。

- 各指令的使用频率相差悬殊
- 指令系统的复杂性使得控制器硬件变得十分复杂
  - 占用大量芯片面积
  - 增加研发成本和时间，容易造成设计错误
- 其 CPI 值比较大，执行速度慢
- 规整性不好，不利于使用流水线技术提高性能

| 指令集结构 | 指令格式           | 寻址方式     | CPI |
| ---------- | ------------------ | ------------ | --- |
| CISC       | 一般采用等长操作码 | 多，复杂     | 高  |
| RISC       | 一般采用定长操作码 | 少，只有几种 | 低  |

$2^{10-\lceil\\log_2{A}\rceil}$

不能，可供单地址指令操作码使用的位数最多只有8位，虽然可以满足单地址指令255条的要求，但是这样就只有3位可供零地址指令操作码使用，无法满足零地址指令16条的要求。

可以。000X-011X为三地址指令，100000000X-111111101X为单地址指令，11111111X为零地址指令。

采用等长操作码编码。

3个寄存器-寄存器指令：前两位为操作码，后续三位和最后三位为寄存器编码。

00XXXYYY

01XXXYYY

10XXXYYY

4个寄存器-存储器型变址寻址指令：前4位为操作码，后续三位为寄存器编码，接着一位为变址寄存器编码，剩余8位为偏移值。

1100XXXYDDDDDDDD

1101XXXYDDDDDDDD

1110XXXYDDDDDDDD

1111XXXYDDDDDDDD

（1）63、64

0000X-1110X为二地址指令

1111000000X-1111111110X为单地址指令

1111111111X为零地址指令

（2）14、126、126

0000X-1101X为二地址指令

1110000000X-1111111101X为单地址指令

1111111110000000-1111111111111101为零地址指令

## 第三章

1.略

流水线特点：

* 流水过程由多个相关的子过程组成，这些子过程称为流水线的“ 级”或“ 段”。段的数目称为流水线的“ 深度”
* 每个子过程由专用的功能段实现
* 各功能段的时间应基本相等，通常为1个时钟周期（ 1拍）
* 流水线需要经过一定的通过时间才能稳定
* 流水技术适合于大量重复的时序过程
* 预测分支失败：流水线照常流动，如果分支成功则要清空流水线，重新取值执行
* 预测分支成功：始终预测分支成功，直接从目标处取值执行
* 延迟分支：分支开销为n的分支指令后紧跟有n个延迟槽，遇到分支指令时正常处理并执行延迟槽中指令，减少分支开销。

![1700540343088](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700540343088.png)

![1700541487798](images/1700541487798.png)

12个指令周期

## 第四章

1.略

2.略

```text
LD 	F0,0(R1)
LD 	F1,-8(R1)
MULTD 	F0,F0,F2
NULTD 	F1,F1,F2
LD 	F4,0(R2)
LD 	F5-8(R2)
ADDD 	F0,F0,F4
ADDD 	F1,F1,F5
SUBI 	R1,R1,16 #op到sd操作有两个延迟
SD 	0(R2),F0
SD 	-8(R2),F1
BNEQZ 	R1,LOOP
SUBI 	R2,R2,16  #注意延迟槽
```

（1）失效开销=命中但是预测错误开销+不命中开销

CPI=1+15%\*(90%\*10%\*4+10%\*3)=1.099

（2）固定两个时延的策略CPI=1+15%\*2=1.3

所以分支目标缓冲更快

失效开销=不命中时间

CPI=1+5%\*(10%*3)=1.015

这里不命中开销沿用上题

（1）

```text
LD
STALL
MULTD
LD
STALL
STALL
ADDD
STALL
STALL
SD
ADDI
ADDI
SGTI
BEQZ
```

14个周期，5个空转周期

（2）

循环展开时，控制部分不需要重复执行，即（1）中11-14行只用执行一遍，而1-10行需要重复执行，并且重复执行之间不需要插入空转周期，所以一共需要10\*4+4=44个周期，而空转周期为5\*4=20，计算一个Y需要11个周期，加速比=14/11，通过减少控制指令的开销获得的

（3）

```text
LD
LD
LD
LD
MULTD
MULTD
MULTD
MULTD
LD
LD
LD
LD
ADDD
ADDD
ADDD
ADDD
SD
SD
SD
SD
ADDI 
ADDI 
SGTI
BEQZ #这里不需要放延迟槽是因为分支延迟为0
```

（4）注意：分支操作完成后才能进行确认，以及CDB的竞争。这里的执行时延取决于指令与指令所需数据来源的指令在表中的时延，比如：第一个ld在3拍将数据传给multd，而ld后的multd有一拍的时延，所以直到第4拍才执行

| 指令  | 流出 | 执行 | 写回 | 确认 |
| ----- | ---- | ---- | ---- | ---- |
| ld    | 1    | 2    | 3    | 4    |
| multd | 2    | 4    | 5    | 6    |
| ld    | 3    | 4    | 6    | 7    |
| addd  | 4    | 7    | 8    | 9    |
| sd    | 5    | 10   | 11   | 12   |
| addi  | 6    | 7    | 8    |      |
| addi  | 7    | 8    | 9    |      |
| sgti  | 8    | 9    | 10   |      |
| beqz  | 9    | 10   |      |      |
| ld    | 10   | 11   | 12   | 13   |
| multd | 11   | 13   | 14   | 15   |
| ld    | 12   | 13   | 15   | 16   |
| addd  | 13   | 16   | 17   | 18   |
| sd    | 14   |      |      |      |
| addi  | 15   | 16   | 17   |      |
| addi  | 16   | 17   | 18   |      |
| sgti  | 17   | 18   |      |      |
| beqz  | 18   |      |      |      |

ROB

（5）

| 整数 | 浮点  | 时钟 |
| ---- | ----- | ---- |
| ld   |       | 1    |
| ld   |       | 2    |
| ld   | multd | 3    |
| ld   | multd | 4    |
| ld   | multd | 5    |
| ld   | multd | 6    |
| ld   | addd  | 7    |
| ld   | addd  | 8    |
| addi | addd  | 9    |
| sd   | addd  | 10   |
| sd   |       | 11   |
| sd   |       | 12   |
| sd   |       | 13   |
| addi |       | 14   |
| sgti |       | 15   |
| beqz |       | 16   |

（6）

| 访存1 | 访存2 | 浮点1 | 浮点2 | 整数 | 时钟 |
| ----- | ----- | ----- | ----- | ---- | ---- |
| ld    | ld    |       |       |      | 1    |
| ld    | ld    |       |       |      | 2    |
| ld    | ld    | multd | multd | addi | 3    |
| ld    | ld    | multd | multd |      | 4    |
|       |       | addd  | addd  | addi | 5    |
|       |       | addd  | addd  | sgti | 6    |
|       |       |       |       | beqz | 7    |
| sd    | sd    |       |       |      | 8    |
| sd    | sd    |       |       |      | 9    |

（1）

| 访存 | 运算 | 时钟 |
| :--: | ---- | :--: |
|  LW  |      |  1  |
|  LW  |      |  2  |
|      |      |  3  |
|      |      |  4  |
|  LD  | ADD  |  5  |
|      | MUL  |  6  |
|  SW  | SUB  |  7  |
|  SW  | MUL  |  8  |
|      |      |  9  |
|  SW  |      |  10  |

（2）

| 1   | 2   | 时钟 |
| --- | --- | ---- |
| LW  | LW  | 1    |
|     |     | 2    |
|     |     | 3    |
| ADD | LD  | 4    |
| SUB | MUL | 5    |
| SW  | MUL | 6    |
|     |     | 7    |
| SW  | SW  | 8    |

（3）

|  1  |  2  | 时钟 |
| :-: | :-: | :--: |
| LW | LW |  1  |
| ADD | LD |  2  |
| MUL | SUB |  3  |
| SW | MUL |  4  |
| SW | SW |  5  |

![1700662867059](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700662867059.png)

![1700662881397](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700662881397.png)

![1700662925648](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700662925648.png)

## 第五章

1.略

2.![1700714717241](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700714717241.png)

编译器控制预取：由编译器加入预取指令，在数据被用到之前发出预取请求

编译器优化：在编译时对程序中的指令和数据进行重新组织

* 将程序中的重要过程重新排序
* 对分支指令的优化
  * 将转移目标出的基本块和紧跟着分支指令后的基本快进行对调
  * 把该分支指令转换为语义相反的分支指令
* 对数组循环进行优化
  * 数组合并
  * 内外循环交换
  * 循环融合
  * 分块

计算结果都是原cache时的时钟周期

（1）

原cache平均访存时间=1+0.56%\*20=1.112

路预测cache平均访存时间=1/2+0.25\*0.9841\*2/2+0.0159*20=1.064025

1.112/1.064025=1.045

（2）

预测失败但命中的开销变为15，不命中开销仍为20

平均访存时间=1/2+0.25\*0.9841\*15/2+0.0159\*20=2.66

不合适

（1）

不采用请求字：失效开销=100+16*3=148

采用请求字：失效开销=100+4=104

（2）L1cache。cache块大小，指令访存顺序

分离cache失效率=75%\*0.39%+25%\*4.82%=1.4975%

混合cache失效率=1.35%

分离cache平均访存时间=1+1.4975%\*50=1.074875

混合cache平均访存时间=75%\*(1+1.35%\*50)+25%\*(2+1.35%\*50)=1.925

分别计算读、写命中和不命中的比例和实际访存次数，相乘再相加

（1）写直达

读命中：75%（读操作比例）\*95%（cache命中率）=71.25%，不访存

读不命中：75%\*5%=3.75%，调入cache整个块，所以访存两次

写命中：25%\*95%=23.75%，因为写直达，所以访存一次

写不命中：25%\*5%=1.25%，需要先调入cache中，修改后再写回主存（这是因为采用的写回法，所以需要不仅写入cache，也写入主存）访存3次

一次访存的平均访存次数：0.35

（2）写回

读命中，写命中都不需要访存，95%

读不命中：分两种情况

* 被替换的块没有被修改，访存两次，75%\*5%\*70%=2.625%
* 被修改，访存4次（写回旧的两次，调入新的两次），75%\*5%\*30%=1.125%

写不命中：分两种情况

* 被替换的块没被修改，访存两次（这里只用把新的调入，不需要修改后写回），25%\*5%\*70%=0.875%
* 被修改，访存4次（旧的写回两次，新的调入两次，修改后不写回），25%\*5%\*30%=0.375%

一次访存平均访存次数：0.13

## 第六章

1.略

2.

假设系统处理时间为100，则CPU处理时间为90，I/O处理时间为10

改进后，CPU处理时间为0.9，I/O处理时间为5

3.略

4.略

5.略

6.![1700744427741](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700744427741.png)![1700744437427](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700744437427.png)

7.略

8.

![1700744609915](https://file+.vscode-resource.vscode-cdn.net/d%3A/code/Learning/Computer_Architecture/note/images/1700744609915.png)

- 在用户程序中使用访管指令进入管理程序，由管理程序生成一个通道程序，并启动通道
- 通道处理机执行通道程序，完成指定的数据输入/输出工作
- 通道程序结束后向 CPU 发中断请求

9.

系统中的平均任务数=到达率\*平均相应时间

所有稳定系统，只要黑盒内不断产生和消灭任务

10.

$\lambda=\frac{1}{50},\mu=\frac{1}{50},\rho=1$

则

系统没有任务的概率为0

队列中平均任务数=$\rho^2(1-\rho)=0$

平均等待时间为0

平均响应时间0

11.


* 存储器中可能不是CPU产生的最新数据 ，所以I/O系统从存储器中取出来的是陈旧数据
* I/O系统与存储器交换数据之后，在Cache中，被CPU使用的可能就会是陈旧数据

第一个问题可以用写直达Cache解决

第二个问题操作系统可以保证I/O操作的数据不在cache中。如果不能，就作废Cache中相应的数据

12.略

# 附录

1.5跑图代码

```python
import matplotlib.pyplot as plt
import numpy as np

def f(x):
    return x/(0.9*x+0.1)

a=np.linspace(0.1,100,1000)
s=f(a)
plt.plot(a,s,'r-')
plt.show()
```

1.6跑图代码

```python
import matplotlib.pyplot as plt
import numpy as np

def f(x):
    return 20/(20-19*x)

a=np.linspace(0,1,1000)
s=f(a)
plt.plot(a,s,'r-')
plt.show()
```

1.8(3)计算代码

```python
import matplotlib.pyplot as plt
import numpy as np

T=100
a=np.array([2,4/3,10/3,4])
p=np.array([10,30,35,15])/10**6
w=T
for i in range(4):
    w-=100*p[i]
o=p/a
print(T/(o.sum()+w))
```
