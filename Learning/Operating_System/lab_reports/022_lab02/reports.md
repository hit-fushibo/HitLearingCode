# 操作系统实验二报告

## 当执行完 `system_interrupt`函数，执行 `153`行 `iret`时，记录栈的变化情况

![1699192259475](images/1699192259475.png)

上图为 `system_interrupt`函数内容，其中 `153`行的 `iret`用于在处理器状态转移期间从中断或异常处理程序返回到被中断的程序，还原被中断程序的执行环境，包括寄存器、堆栈以及特权级别的状态。

- 在执行 iret 前，栈的内容如下图：

  ![1699192419492](images/1699192419492.png)

  从上往下依次是：

| 内容   | 含义                         |
| ------ | ---------------------------- |
| 0x10eb | 即将弹出的 EIP 寄存器的值    |
| 0x000f | 即将弹出的 CS 寄存器的值     |
| 0x0246 | 即将弹出的 EFLAGS 寄存器的值 |
| 0x0bd8 | 即将弹出的 ESP 寄存器的值    |

- 在执行完 iret 后，发生了栈切换，栈的内容如下图：

  ![1699192677862](images/1699192677862.png)

## 当进入和退出 `system_interrupt`时，都发生了模式切换，请总结模式切换时，特权级是如何变化的？栈切换吗？如何进行切换的？

### 特权级

- 进入 `system_interrupt`：从用户态（特权级 3）转变到了内核态（特权级 0）
- 退出 `system_interrupt`：从内核态（特权级 0 转变到了）用户态（特权级 3）

### 栈

在进入和退出 `system_interrupt`时发生了栈切换。

### 如何进行切换

在模式切换之前，当前执行的任务的上下文以及当前特权级需要被保存压入栈中，根据要切换到的特权级别，操作系统选择新的代码段描述符和堆栈描述符， 切换堆栈和特权级 ，并将它们加载到相应的寄存器中。

## 当时钟中断发生，进入到 `timer_interrupt` 程序，请详细记录从任务 `0` 切换到任务 `1` 的过程

![1699192917182](images/1699192917182.png)

时钟中断程序如上图所示。

![1699192956706](images/1699192956706.png)

任务 `0` 和任务 `1` 的内容如上图，它们分别循环打印 A 和 B。

在时钟中断程序中，首先将任务 `0` 存入 current，即 `128`行。之后通过 `129`行的 `ljmp`指令从任务 `1` 切换到任务 `0`。

在进行切换之前，首先要将当前任务的各寄存器状态和值存入 `tss0` 内。以便状态的恢复。

之后需要找到新任务即任务 `1`的 `tss`，并加载各寄存器的值。在这里，通过`$TSS1_SEL` 选择符从 `gdt` 中找到 `tss1` 的地址。然后从 `tss1` 获取任务 `1` 各寄存器的值，根据这些值恢复任务 `1` 的上下文。

最后根据新加载的 `cs:ip` 和各寄存器的值执行任务 `1`。

## 又过了 `10ms` ，从任务 `1`切换回到任务 `0` ，整个流程是怎样的？ `TSS` 是如何变化的？各个寄存器的值是如何变化的？

与从任务 `0` 切换到任务 `1` 类似。首先将任务 `1` 存入 `current`。之后通过 `ljmp` 指令从任务 `1` 切换回任务 `0`。

在执行 `ljmp` 指令之前，`tss1` 的状态：

![1699193836731](images/1699193836731.png)

寄存器状态：

![1699193912285](images/1699193912285.png)

执行之后，`tss1` 的状态：

![1699193861460](images/1699193861460.png)

寄存器状态：

![1699193933090](images/1699193933090.png)

## 请详细总结任务切换的过程

时钟中断是多任务处理的触发点，它以固定的时间间隔每 10 毫秒发生一次。

当时钟中断触发时，操作系统会执行时钟中断处理程序。

在处理程序执行之前，当前正在执行的任务 A 的上下文会被保存，包括寄存器的状态（如 EAX、ECX、EDX、EFLAGS、ESP、CS、EIP 等）保存在任务 A 的 TSS（任务状态段）中。

在时钟中断处理程序中，操作系统会选择下一个要执行的任务 B，并将任务 B 的上下文信息存储在任务 B 的 TSS 中。

然后，时钟中断处理程序通过任务 B 的 TSS 将任务 B 的上下文信息（寄存器的值）加载到处理器中，处理器现在准备执行任务 B。

如果任务 A 和任务 B 使用不同的内核堆栈，堆栈指针寄存器 ESP 将从任务 A 的内核堆栈切换到任务 B 的内核堆栈，以确保任务 B 可以正常执行内核代码。

如果任务 A 和任务 B 属于不同的特权级别，时钟中断处理程序会执行特权级别切换操作。然

后，任务 B 的上下文准备就绪并加载到处理器中，任务 B 开始执行。

时钟中断处理程序执行完毕后，处理器返回到任务 B 的执行点，任务 B 继续执行。
