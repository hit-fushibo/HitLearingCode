# 进程运行轨迹的跟踪与统计

## 实验结果

### process.c

见代码目录

### 日志文件建立成功

![1702045065546](images/1702045065546.png)

### 能向日志输出信息

![1702045096495](images/1702045096495.png)

### 5 种状态都能输出

![1702045175645](images/1702045175645.png)

### 调度算法更改

见代码目录

## 问题回答

### 结合自己的体会，谈谈从程序设计者的角度看，单进程编程和多进程编程最大的区别是什么？

在单进程编程中，程序是顺序执行的，一次只能执行一个任务。这意味着程序设计相对简单，因为不需要考虑并发执行时可能出现的竞争条件、死锁等问题。单进程编程更适合于简单的、线性的任务，例如一些简单的脚本或者小型的应用程序。

相比之下，多进程编程允许程序同时执行多个任务，这样可以提高系统的整体性能。但是，多进程编程需要考虑更多的并发性问题，如进程间通信、同步、资源共享等，这增加了程序设计的复杂性。此外，多进程编程也需要更多的系统资源和内存开销。

### 你是如何修改时间片的？仅针对样本程序建立的进程，在修改时间片前后， `log` 文件的统计结果（不包括 Graphic）都是什么样？结合你的修改分析一下为什么会这样变化，或者为什么没变化？

在 `sched.h`中，通过宏定义了时间片的大小，对应的语句为

```cpp
#define INIT_TASK { 0,15,15, ...}
```

上述三个值分别对应 state、counter 和 priority。

默认为 15 时结果

![1702045542639](images/1702045542639.png)

修改为 150 之后的结果

![1702045563863](images/1702045563863.png)

修改时间片后，发现利用率降低了，原因可能是时间片分配的过大导致实际上程序执行完毕后要等一会才能切换。

## 修改的文件

./code/linux-0.11/kernel/exit.c

./code/linux-0.11/kernel/fork.c

./code/linux-0.11/init/main.c

./code/linux-0.11/kernel/sched.c

./code/linux-0.11/kernel/printk.c

## 输出文件

| 文件                   | 含义                      |
| ---------------------- | ------------------------- |
| ./code/process_15.log  | 正常情况下输出文件        |
| ./code/process_150.log | 修改时间片为150后输出文件 |
