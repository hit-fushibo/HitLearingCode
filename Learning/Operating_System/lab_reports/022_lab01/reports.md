# 操作系统实验一报告

## 简述 `head.s`的工作原理

在操作系统启动时，BIOS或UEFI固件将引导扇区加载到内存中，并跳转到引导扇区的代码执行。引导扇区会读取操作系统内核的第一个扇区（内核镜像）并加载到内存中，然后跳转到内核镜像的入口点开始执行。这个入口点通常由head.s文件定义，并在链接时确定内核代码的起始地址。

在head.s文件中，堆栈通常通过将栈指针寄存器（如ESP或SP）设置到堆栈顶部来设置。堆栈是预先分配的一段连续内存区域，通常从高地址向低地址生长。堆栈指针会初始化为堆栈的最高地址，以便后续的函数调用和返回操作能正确执行。

head.s文件还负责初始化系统状态，包括清除内存中的数据、设置段寄存器和禁止中断。清零内存通常通过rep stosb指令实现，段寄存器设置为正确的值，禁止中断通过将中断标志位清零来实现。

最后，在head.s文件中，跳转到C代码是通过函数调用实现的。函数调用通常通过将返回地址压入堆栈中，然后跳转到函数入口点开始执行。在跳转到C代码之前，需要确保调用约定与C代码一致，以便正确传递参数和返回值。在x86架构中，常用的调用约定是cdecl，参数从右向左压入堆栈中，eax寄存器用于返回函数的返回值。

## 记录 `head.s`的内存分布情况，写明每个数据段，代码段，栈段的起始与终止内存地址

数据段：

| 数据段编号 | 名称         | 起始地址 | 终止地址 |
| :--------: | ------------ | -------- | -------- |
|     1     | current      | 0x17d    | 0x180    |
|     2     | scr_ loc     | 0x181    | 0x184    |
|     3     | lidt_ opcode | 0x186    | 0x18b    |
|     4     | Igdt opcode  | 0x18c    | 0x191    |
|     5     | idt          | 0x198    | 0x997    |
|     6     | gtd          | 0x998    | 0x9d7    |
|     7     | ldt0         | 0xbe0    | 0xbf7    |
|     8     | tss0         | 0xbf8    | 0xc5f    |
|     9     | ldt1         | 0xc60    | 0xe77    |
|     10     | tss1         | 0xe78    | 0xedf    |

代码段：

| 代码段编号 |       名称       | 起始地址 | 终止地址 |
| :--------: | :---------------: | :------: | :------: |
|     1     |    startup_ 32    |   0x00   |   0xac   |
|     2     |    setup_ idt    |   0xb5   |   0xe4   |
|     3     |    setup_ gdt    |   0xad   |   0xb4   |
|     4     |    write_ char    |   0xe5   |  0x113  |
|     5     |    ignore_ int    |  0x114  |  0x129  |
|     6     | timer_ interrupt |  0x12b  |  0x165  |
|     7     | system_ interrupt |  0x166  |  0x17c  |
|     8     |       task0       |  0x10e0  |  0x10f3  |
|     9     |       task1       |  0x10f4  |  0x1107  |

堆栈段：

| 堆栈段编号 |    名称    | 起始地址 | 终止地址 |
| :--------: | :--------: | :------: | :------: |
|     1     | Init stack |  0x9d8  |  0xbd8  |
|     2     | Krn_ stk0 |  0xc60  |  0xe60  |
|     3     | Krn_ stk1 |  0xe00  |  0x10e0  |
|     4     | User_ stk1 |  0x1108  |  0x1308  |

## `head.s`的57至62行在做什么

57:把任务0当前局部空间数据段(堆栈段)选择符入栈

58:把堆栈指针入栈( 也可以把ESP入栈)

59:把标志寄存器入栈

60:把当前局部空间代码段选择符入栈

61:把代码指针入栈

62:执行中断返回指令，从而切换到特权级3的任务0中执行

## `iret`执行后，`pc`时如何找到下一条指令的

1. 当执行 `iret`指令时，它会从堆栈中弹出被保存的标志寄存器、代码段选择子和返回地址。
2. 弹出的代码段选择子会被加载到CS寄存器中，而返回地址会被加载到EIP寄存器中。
3. 一旦CS和EIP寄存器中的值被更新，处理器会从新的CS:IP地址开始执行下一条指令。
4. 处理器根据新的CS:IP地址访问内存，获取下一条指令的机器码，并将其加载到指令寄存器中。
5. 指令寄存器中的指令被解码和执行，程序继续执行下一条指令。

## `iret`执行前后，栈是如何变化的

执行前:
栈中的内容就是上面57-62行指令压入的内容。栈指针esp=0x0bc4。

|  地址  |   值   |
| :----: | :----: |
| 0x0bc4 | 0x10e0 |
| 0x0bc8 |  0x0f  |
| 0x0bcc | 0x246 |
| 0x0bd0 | 0xbd8 |
| 0x0bd4 |  0x17  |
| 0x0bd8 | 0xbd8 |

执行后:
将上述内容全部弹出，使程序返回到原来发生中断的地方。栈指针esp=0x0bd8。

| 地址   | 值    |
| ------ | ----- |
| 0x0bd8 | 0xbd8 |

## 当任务进行系统调用时，即 `int 0x80`时记录栈的变化情况

执行系统调用int 0x80前，栈为task0或者task1的用户栈，栈的内容:

| 地址   | 值    |
| ------ | ----- |
| 0x0bd8 | 0xbd8 |

执行系统调用int 0x80后， 堆栈变为此任务的系统栈，而在这系统栈中自动压入了发生中断之前的ss、栈指针、标志寄存器、cs和下一条指令的eip。栈的内容:

|  地址  |   值   |
| :----: | :----: |
| 0x0e4c | 0x10eb |
| 0x0e50 |  0x0f  |
| 0x0e54 | 0x246 |
| 0x0e58 | 0xbd8 |
| 0x0e5c |  0x17  |
