# 中断和异常处理

## 中断和异常处理概述

中断和异常是表明系统、处理器中或当前正在执行的程序或任务中存在需要处理器注意的条件的事件。它们通常会导致执行从当前运行的程序或任务强制转移到称为中断处理程序或异常处理程序的特殊软件例程或任务。处理器响应中断或异常而采取的操作称为服务或处理中断或异常。

中断在程序执行期间随机发生，以响应来自硬件的信号。系统硬件使用中断来处理处理器外部的事件，例如服务外围设备的请求。软件还可以通过执行 INT n 指令来生成中断。

当处理器在执行指令时检测到错误情况（例如被零除）时，就会发生异常。处理器检测各种错误情况，包括保护违规、页面错误和内部机器故障。 Pentium 4、Intel Xeon、P6 系列和 Pentium 处理器的机器检查架构还允许在检测到内部硬件错误和总线错误时生成机器检查异常。

当接收到中断或检测到异常时，当前运行的过程或任务将被挂起，同时处理器执行中断或异常处理程序。当处理程序的执行完成时，处理器恢复执行被中断的过程或任务。被中断的过程或任务的恢复不会丢失程序的连续性，除非无法从异常中恢复或者中断导致当前正在运行的程序终止。

## 中断和异常

### 中断和异常向量

为了帮助处理异常和中断，需要处理器进行特殊处理的每个体系结构定义的异常和每个中断条件都被分配了一个唯一的标识号，称为向量号。处理器使用分配给异常或中断的向量号作为中断描述符表 (IDT) 的索引。该表提供异常或中断处理程序的入口点。

向量编号的允许范围是 0 到 255。0 到 31 范围内的向量编号由 Intel 64 和 IA-32 体系结构保留，用于体系结构定义的异常和中断。并非该范围内的所有向量编号都具有当前定义的函数。该范围内未分配的向量号被保留。不要使用保留的向量编号。32 到 255 范围内的向量编号被指定为用户定义的中断，并且不被 Intel 64 和 IA-32 体系结构保留。这些中断通常分配给外部 I/O 设备，以使这些设备能够通过外部硬件中断机制之一向处理器发送中断。

![1697114447105](images/1697114447105.png)

![1697114468170](images/1697114468170.png)

### 中断源和异常源

#### 中断源

处理器从两个来源接收中断：

* 外部（硬件生成）中断。
* 软件生成的中断。

##### 外部中断

外部中断通过处理器上的引脚或者通过本地APIC接收。当本地APIC被启用时，LINT[1: 0]引脚可以通过APIC的本地向量表（LVT）进行编程从而与处理器的任何异常或中断向量相关联；而当本地APIC被仅用时，这些APIC分别被配置为INTR和NMI引脚。处理器的本地APIC用场连接到基于系统的I/O APIC，I/O APIC决定中断向量数。LINT[1: 0]引脚在不包含本地APIC的处理器上不可用，这些处理器的外部中断通常基于系统的中断控制器产生，这些中断通过INTR引脚发出中断信号。

##### 软件中断

INT n 指令允许通过提供中断向量号作为操作数从软件内部生成中断。0 到 255 之间的任何中断向量都可以用作该指令中的参数。然而，如果使用处理器的预定义 NMI 向量，则处理器的响应将与以正常方式生成的 NMI 中断的响应不同。如果该指令中使用向量号 2（NMI 向量），则会调用 NMI 中断处理程序，但不会激活处理器的 NMI 处理硬件。

使用 INT n 指令在软件中生成的中断不能被 EFLAGS 寄存器中的 IF 标志屏蔽。

#### 异常源

处理器从三个来源接收异常： 

* 处理器检测到的程序错误异常
* 软件生成的异常
* 机器检查异常

##### 程序错误异常

当处理器在应用程序或操作系统或执行程序执行期间检测到程序错误时，处理器会生成一个或多个异常。 Intel 64 和 IA-32 架构为每个处理器可检测的异常定义了一个向量号。异常分为故障、陷阱和中止。

##### 软件生成的异常

INTO、INT1、INT3 和 BOUND 指令允许在软件中生成异常。这些指令允许在指令流中的点处执行异常条件检查。INT n指令可用于模拟软件中的异常；但有一个限制。如果 INT n 为架构定义的异常之一提供向量，则处理器会生成正确向量的中断，但不会将错误代码推送到堆栈上。即使相关的硬件生成的异常通常会产生错误代码，情况也是如此。处理异常时，异常处理程序仍会尝试从堆栈中弹出错误代码。由于没有推送错误代码，处理程序将弹出并丢弃 EIP（代替丢失的错误代码）。这会将返回值发送到错误的位置。

##### 机器检查异常

处理器内部有机器检查的机制，当检测到机器错误时，处理器就会发出一个机器检查异常 。此时，处理器会发送及其异常信号，也就是18号向量，并且返回错误代码。

### 异常的分类

异常被分类为故障、陷阱或中止，具体取决于异常的报告方式以及导致异常的指令是否可以在不丢失程序或任务连续性的情况下重新启动。

* 故障 ：故障是一种通常可以纠正的异常，一旦纠正，就可以重新启动程序而不会失去连续性。当报告错误时，处理器将机器状态恢复到开始执行错误指令之前的状态。故障处理程序的返回地址（CS 和 EIP 寄存器的保存内容）指向故障指令，而不是指向故障指令之后的指令。
* 陷阱：陷阱是在执行陷阱指令后立即报告的异常。陷阱允许继续执行程序或任务，而不会丢失程序的连续性。陷阱处理程序的返回地址指向陷阱指令之后要执行的指令。

* 中止：中止是一种异常，它并不总是报告导致异常的指令的精确位置，并且不允许重新启动导致异常的程序或任务。中止用于报告严重错误，例如硬件错误以及系统表中的不一致或非法值。

### 程序或任务的重新执行

为了允许在处理异常或中断后重新启动程序或任务，保证所有异常（中止除外）报告指令边界上的异常。所有中断都保证在指令边界上进行。

对于故障类异常、处理器产生异常时保存的返回指针指向出错指令。因为,当程序或任务在故障处理程序返回后重新开始执行时,原出错指令会被重新执行。重新执行引发出错的指令通常用于处理访问指令操作数受阻的情况。为了确保重新执行对于当前执行程序具有透明性,处理器会保存必要的寄存器和堆栈指针信息, 以使得自己能够返回到执行出错指令之前的状态。

对于陷阱类异常,处理器产生异常时保存的返回指针指向引起陷阱操作的后一条指令。如果在一条执行控制转移的指令执行期间检测到一个 Trap,则返回指令指针会反映出控制的转移情况。例如,如果在执行 JMP 指令时检测到一个 Trap 异常, 那么返回指令指针会指向 JMP 指令的目标位置,而非指向 JMP 指令随后的一条指令。

中止类异常不支持程序或任务的可靠重新启动。中止处理程序旨在收集有关中止异常发生时处理器状态的诊断信息，然后尽可能优雅地关闭应用程序和系统。

中断严格支持重新启动中断的程序和任务，而不会失去连续性。为中断保存的返回指令指针指向处理器获取中断的指令边界处要执行的下一条指令。如果刚刚执行的指令有重复前缀，则在当前迭代结束时进行中断，并将寄存器设置为执行下一次迭代。

### 开启和禁止中断

处理器会根据处理器的状态以及 EFLAGS 寄存器中的 IF 和 RF 标志的状态来禁止某些中断的生成，当 IF=0 时,处理器禁止发送到 INTR 引脚的中断;当 IF=1 时,则发送到 INTR 引脚的中断信号会被处理器进行处理。IF 标志并不影响发送到 NMI 引脚的非屏蔽中断, 也不影响处理器产生的异常。如同 EFLAGS 中的其他标志一样, 处理器在响应硬件复位操作时会清除 IF 标志(IF=0)。

#### 屏蔽可屏蔽硬件中断

IF标志可以禁用INTR引脚上或通过本地APIC接收到的可屏蔽硬件中断的服务。当IF标志清零时，处理器禁止传送到INTR引脚或通过本地APIC生成内部中断请求的中断；当IF标志置位时，传送到INTR或通过本地APIC引脚传送的中断将作为正常外部中断进行处理。

IF标志不会影响传送到NMI引脚的不可屏蔽中断（NMI）或通过本地APIC传送的传送模式NMI消息，也不会影响处理器生成的异常。与EFLAGS寄存器中的其他标志一样，处理器会清除IF标志以响应硬件复位。

可屏蔽硬件中断组包括保留中断和异常向量0到32，这一事实可能会导致混乱。当IF标志被设置时，从0到32的任何向量的中断都可以通过INTR引脚传递到处理器，并且从16到32的任何向量可以通过本地APIC传递。然后处理器将生成一个中断并调用向量号指向的中断或异常处理程序。例如，可以通过INTR引脚（通过向量14）调用页面错误处理程序；然而，这并不是真正的页面错误异常。这是一个中断。与INT n指令一样，当通过INTR引脚生成异常向量中断时，处理器不会将错误代码推送到堆栈上，因此异常处理程序可能无法正常运行。

IF标志可以分别使用STI（设置中断使能标志）和CLI（清除中断使能标志）指令来设置或清除。仅当CPL等于或小于IOPL时，才可以执行这些指令。如果在CPL大于IOPL时执行它们，则会生成一般保护异常（#GP）。如果IF = 0，则在执行STI后，可屏蔽硬件中断在指令边界上保持禁止状态。该禁止在传送另一个事件（例如异常）或下一条指令的执行。

#### 屏蔽指令断点

EFLAGS寄存器中的RF标志控制处理器对指令断点条件的响应。当RF标志被设置时，它可以防止指令断点生成调试异常（#DB）；当RF标志被清除时，指令断点将生成调试异常。RF标志的主要功能是防止处理器在指令断点上进入调试异常循环。

#### 切换堆栈时屏蔽异常和中断

为了解决在切换到新的堆栈段时可能出现的不一致问题，处理器在执行MOV到SS指令或POP到SS指令后会阻止传递某些事件。

* 下一条指令上的任何指令断点都会被抑制，就好像EFLAGS寄存器中的RF标志为1。
* 在执行MOV到SS指令或POP到SS指令时，任何数据断点都会被禁止，直到下一条指令的指令边界。
* 在执行MOV到SS指令或POP到SS指令之后，任何单步陷阱（因为EFLAGS寄存器中的TF标志为1）都会被抑制。
* 抑制和禁止在异常发生或执行下一条指令后结束。
* 如果一系列连续的指令都是加载SS寄存器（使用MOV或POP指令），那么只有第一个指令能够以这种方式禁止或抑制事件。

### 异常和中断的优先级

如果在指令边界（指令执行之间）有多个中断待处理，则处理器会按照可预测的顺序为它们提供服务。处理优先级如下：

![1697115854513](images/1697115854513.png)![1697115867194](images/1697115867194.png)


## 中断描述符表

中断描述符表（IDT）是一个包含每个异常或中断向量与用于服务相关异常或中断的门描述符相关联的数组。与GDT和LDT类似，IDT也是一个8字节描述符数组（在保护模式下）。不同于GDT，IDT的第一个条目可能包含描述符。处理器通过将异常或中断向量乘以8来索引IDT（门描述符中的字节数）。由于只有256个中断或异常向量，因此IDT不需要包含超过256个描述符。它只需要包含可能发生的中断和异常向量所需的描述符。IDT中的所有空描述符槽应将描述符的当前标志设置为0。IDT的基地址应该对齐到8字节边界上，以最大限度地提高缓存行填充的性能。限制值以字节表示，并与基地址相加，得到IDT中最后一个有效字节的地址。限制值为0将导致只有1个有效字节。由于IDT条目的长度始终为8个字节，所以限制值应该小于8的整数倍（即8N-1）。

IDT可以位于线性地址空间中的任何位置。处理器使用IDTR寄存器来定位IDT，IDTR寄存器保存IDT的32位基地址和16位限制。

LIDT（加载IDT寄存器）和SIDT（存储IDT寄存器）指令分别用于加载和存储IDTR寄存器的内容。LIDT指令将存储在内存操作数中的基地址和限制加载到IDTR寄存器中。该指令只能在CPL为0时执行，通常由操作系统的初始化代码在创建IDT时使用。操作系统也可以使用它从一个IDT切换到另一个IDT。SIDT指令将存储在IDTR中的基值和限制值复制到内存中。该指令可以在任何权限级别执行。

## IDT描述符

IDT 包含三种门描述符：

* 任务门描述符
* 中断门描述符
* 陷阱门描述符

下图为各个类型描述符，其中缩写为：

* DPL：中段描述符权限等级
* Offset：偏移量
* P：P标志位
* Selector：段选择符位置代码段
* D：粒度，1 = 32bits；0 = 16bits

阴影部分为保留位。

![1697116218525](images/1697116218525.png)

## 中断和异常处理

### 中断过程调用的流程是怎样的？

当响应异常或中断时，处理器使用异常或中断向量作为IDT中描述符的索引。如果索引指向中断门或陷阱门，处理器调用异常或中断处理程序的方式类似于调用门的CALL；如果index指向一个任务门，处理器执行一个任务切换到异常或中断处理程序任务，方式类似于CALL到任务门。

### 如何判断中断处理过程与被中断任务的优先级？

在处理中断时，处理器会检查当前的特权级别（CPL）和中断描述符的特权级别（DPL）。如果中断描述符的DPL大于或等于当前的CPL，那么处理器会允许中断处理过程执行。

### 不同优先级上，处理方式一样吗？

不一样，如果处理过程在高特权级上运行时会发生堆栈切换操作。

### 如果发生堆栈切换，处理器会做哪些操作？

1. 处理器从当前执行任务的TSS段中得到中断或异常处理过程使用的堆栈的段选择符和栈指针。然后处理器会把被中断程序的栈选择符和栈指针压入新栈中。
2. 处理器把EFLAGS、CD和EIP寄存器的值也压入新栈中
3. 如果异常产生一个错误号，那么该错误号最后被压入新栈中。

### 如果没发生堆栈切换，处理器会做哪些操作？

1. 处理器把EFLAGS、CD和EIP寄存器的值压入当前栈中
1. 如果异常产生一个错误号，那么该错误号最后被压入新栈中。

### 中断处理过程后，如何返回，处理器做了哪些操作？

为了从中断处理过程中返回，处理过程必须使用IRET指令。IRET指令类似于RET指令，但会恢复保存的寄存器内容到EFLAGS中。然而，只有当CPL为0时，才会恢复EFLAGS中的IOPL字段，且只有当CPL<=IOPL时，IF标志才会被改变。如果在调用中断处理过程时发生了堆栈切换，返回时IRET指令会切换回原来的堆栈。

### 异常和中断处理过程的保护

异常和中断处理过程的特权级保护机制与通过调用门调用普通过程类似。处理器不允许把控制转移到比 CPL 更低特权级代码段的中断处理过程中, 否则将产生一个一般保护性异常。

### 异常和中断处理过程的标志使用方式

当通过中断门或陷阱门访问一个异常或中断处理过程时,处理器会在把 EFLAGS 寄存器内容保存到堆栈上之后清除 EFLAGS 中的 TF 标志。清除 TF 标志可以防止指令跟踪影响中断响应。而随后的 IRET 指令会用堆栈上的内容恢复 EFLAGS 的原 TF 标志。

### 中断门与陷阱门的唯一区别是什么？

中断门与陷阱门唯一的区别在于处理器操作 EFLAGS 寄存器 IF 标志的方法。当通过中断门访问一个异常或中断处理过程时,处理器会复位 IF 标志以防止其他中断干扰当前中断处理过程。随后的 IRET 指令则会用保存在堆栈上的内容恢复 EFLAGS 寄存器的 IF 标志。而通过陷阱门访问处理过程并不会影响 IF 标志。
