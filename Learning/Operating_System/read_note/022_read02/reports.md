# 保护模式内存管理

## 内存管理概览

x86架构的内存管理设施分为两个部分：分段和分页。

分段提供了一种隔离各个代码、数据和堆栈模块的机制，以便多个程序（或任务）可以在同一处理器上运行而不会相互干扰。分页提供了一种实现传统的按需分页虚拟内存系统的机制，其中程序执行环境的各个部分根据需要映射到物理内存中。分页还可用于提供多个任务之间的隔离。当在保护模式下运行时，必须使用某种形式的分段。没有模式位可以禁用分段。然而，分页的使用是可选的。

![1695818624481](images/1695818624481.png)

如上图所示，分段提供了一种将处理器的可寻址内存空间（称为线性地址空间）划分为更小的受保护地址空间（称为段）的机制。段可用于保存程序的代码、数据和堆栈，或保存系统数据结构（例如 TSS 或 LDT）。如果一个处理器上运行多个程序（或任务），则可以为每个程序分配其自己的一组段，确保一个程序不会通过写入另一个程序的段来干扰另一个程序的执行。分段机制还允许分段的类型，从而可以限制可以对特定类型的分段执行的操作。系统中的所有段都包含在处理器的线性地址空间中。要在特定段中定位字节，必须提供逻辑地址（也称为远指针）。逻辑地址由段选择器和偏移量组成。段选择器是段的唯一标识符。除此之外，它还提供描述符表（例如全局描述符表，GDT）到称为段描述符的数据结构的偏移量。每个段都有一个段描述符，它指定了段的大小、段的访问权限和特权级别、段类型以及该段的第一个字节在线性地址空间中的位置（称为段的基地址）段）。逻辑地址的偏移部分被添加到段的基地址上以定位段内的字节。基地址加上偏移量就形成了处理器线性地址空间中的线性地址。如果不使用分页，则处理器的线性地址空间直接映射到处理器的物理地址空间。物理地址空间定义为处理器可以在其地址总线上生成的地址范围。由于多任务计算系统通常定义的线性地址空间远大于物理内存，因此需要某种“虚拟化”线性地址空间的方法。线性地址空间的虚拟化是通过处理器的分页机制来处理的。分页支持“虚拟内存”环境，其中使用少量物理内存（RAM 和 ROM）和一些磁盘存储来模拟大型线性地址空间。使用分页时，每个段被分为页（通常每个大小为 4 KB），这些页存储在物理内存或磁盘上。操作系统或执行程序维护一个页目录和一组页表来跟踪页面。当程序尝试访问线性地址空间中的地址位置时，处理器使用页目录和页表将线性地址转换为物理地址，然后在该地址上执行请求的操作。

一般来说，逻辑地址（Logical Address）是指在计算机体系结构中，由CPU生成的地址。它是一个虚拟的地址空间，用于表示程序或进程在逻辑上的存储位置。逻辑地址通常是相对于一个特定的地址空间的偏移量，这个地址空间可以是进程的虚拟地址空间或者是操作系统的内存管理单元。线性地址（Linear Address）是指在操作系统的内存管理单元中，由CPU生成的地址。它是逻辑地址通过分段（Segmentation）或分页（Paging）机制转换后得到的地址。线性地址是一个相对于整个系统内存空间的地址，它可以被操作系统用来访问实际的物理内存。物理地址（Physical Address）是指计算机中实际的内存地址。它是CPU通过内存管理单元将线性地址转换为实际的存储器位置得到的地址。物理地址是一个直接用于访问内存的地址，它指向计算机的物理存储器单元。在计算机的内存管理过程中，逻辑地址通过分段或分页机制转换为线性地址，线性地址再通过内存管理单元转换为物理地址。这个转换过程是由操作系统的内存管理模块完成的，它负责将逻辑地址映射到实际的物理内存位置，以实现程序的正确执行和内存的合理利用。

## 分段机制

分段机制可用于实现多种系统设计。这些设计范围从使用分段机制的最小功能来保护程序的平坦模型, 到使用分段机制创建一个可同时可靠地运行多个程序(或任务)的具有稳固操作环境的多段模型。
多段模型能够利用分段机制全部功能提供由硬件增强的代码、数据结构、程序和任务的保护措施。通常,每个程序(或任务)都使用自己的段描述符表以及自己的段。对程序来说段能够完全是私有的,或者是程序之间共享的。对所有段以及系统上运行程序各自执行环境的访问都由硬件控制。

在保护模式中，x86提供了4GB的物理空间，地址范围从0到0xFFFFFFFF。分段机制就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元。x86虚拟地址空间总的虚拟地址（逻辑地址）由一个段部分和一个偏移部分构成。段时虚拟地址到线性地址转换机制的基础。，每个段由三个参数定义：

* 段基地址，指定段在线性地址空间中的开始地址。基地址是线性地址，对应段中偏移为0处。
* 段限长，是虚拟地址空间中段内最大可用偏移地址，定义了段的长度。
* 段属性，指定段的特性。例如是否可读、可写或可执行，段的特权级等。

段基址和段限长确定了段所映射的线性地址范围。多个段映射到线性地址中的范围可以部分重叠甚至完全重叠。这三个参数存储在一个称为段描述符的结构体中。在逻辑地址到线性地址的转换中要用到这个段描述符。段描述符保存在内存中的段描述符表中。

### Basic Flat Model（基本平面模型）

系统最简单的内存模型是基本的“平面模型”，其中操作系统和应用程序可以访问连续的、未分段的地址空间。这种基本的平面模型最大程度地向系统设计者和应用程序员隐藏了架构的分段机制。

![1695820621779](images/1695820621779.png)

要实现基本平面内存模型，必须至少创建两个段描述符，一个用于引用代码段，另一个用于引用数据段（见图 ）。然而，这两个段都映射到整个线性地址空间：也就是说，两个段描述符具有相同的基地址值 0 和相同的 4 GB 段限制。通过将段限制设置为 4 GB，即使特定地址没有物理内存驻留，分段机制也不会因超出限制的内存引用而生成异常。 ROM（EPROM）一般位于物理地址空间的顶部，因为处理器从FFFF_FFF0H开始执行。 RAM（DRAM）被放置在地址空间的底部，因为复位初始化后DS数据段的初始基地址为0。

### Protected Flat Model（受保护的平面模型）

受保护的平面模型与基本平面模型类似，不同之处在于段限制设置为仅包括物理内存实际存在的地址范围（见图）。如果尝试访问不存在的内存，则会生成一般保护异常 (#GP)。该模型针对某些类型的程序错误提供了最低级别的硬件保护。

![1695820711111](images/1695820711111.png)

可以向此受保护的平面模型添加更多复杂性，以提供更多保护。例如，对于在用户和管理员的代码和数据之间提供隔离的分页机制，需要定义四个段：用户的特权级别3的代码和数据段，以及管理员的特权级别0的代码和数据段。通常这些段都相互重叠，并从线性地址空间中的地址 0 开始。这种扁平分段模型以及简单的分页结构可以保护操作系统免受应用程序的影响，并且通过为每个任务或进程添加单独的分页结构，它还可以保护应用程序免受彼此的影响。

### Multi-Segment Model（多段模型）

![1695820817585](images/1695820817585.png)

多段模型（如图所示）使用分段机制的全部功能来提供对代码、数据结构以及程序和任务的硬件强制保护。这里，每个程序都有自己的段描述符表和自己的段。这些段对于其分配的程序来说可以是完全私有的，也可以在程序之间共享。对系统上运行的各个程序的所有段和执行环境的访问均由硬件控制。

访问检查不仅可用于防止引用段限制之外的地址，还可防止在某些段中执行不允许的操作。例如，由于代码段被指定为只读段，因此可以使用硬件来防止写入代码段。为段创建的访问权限信息还可用于设置保护环或级别。保护级别可用于保护操作系统过程免遭应用程序未经授权的访问。

## 逻辑地址和线性地址的转换

![1695820001321](images/1695820001321.png)

使用逻辑地址也可以访问处理器地址中的每个字节。如上图所示，逻辑地址由 16 位的段选择符和 32 位的偏移量组成,。段选择符指定字节所在的段, 而偏移量指定该字节在段中相对于段基地址的位置。处理器会把每个逻辑地址转换成线性地址。线性地址是处理器线性地址空间中的32 位地址。与物理地址空间类似,线性地址空间也是平坦的 4GB 地址空间,地址范围从 0 到 0xFFFFFFFF。线性地址空间中含有为系统定义的所有段和系统表。

为了把逻辑地址转换为一个线性地址，处理器会进行如下操作：

1. 使用段选择符中的偏移值在GDT或LDT中定位相应的段描述符。仅当一个新的段选择符加载到段寄存器时才需要这一步
2. 利用段描述符检验段的访问权限和范围，以确保该段是可访问的并且偏移量位于段界限内。
3. 把段描述符中取得的段基址加到偏移量上，形成线性地址。

如果没有开启分页，那么处理器直接把线性地址映射成为物理地址。如果对线性地址空间进行了分页处理，那么就会使用二级地址转换把线性地址转换成物理地址。

### 段选择子

![1695820997928](images/1695820997928.png)

段选择器是段的 16 位标识符（见图 ）。它并不直接指向段，而是指向定义该段的段描述符。段选择器包含以下内容：

1. 索引：（位 3 到 15）— 选择 GDT 或 LDT 中的 8192 个描述符之一。处理器将索引值乘以 8（段描述符中的字节数），并将结果添加到 GDT 或 LDT 的基地址（分别来自 GDTR 或 LDTR 寄存器）。
2. 表指示器标志：(位 2) — 指定要使用的描述符表：置零该标志将选择 GDT；置一此标志选择当前 LDT。
3. 请求权限级别：（位 0 和 1）— 指定选择器的权限级别。权限级别的范围为 0 到 3，其中 0 是最高权限级别。

处理器不使用 GDT 的第一个条目。指向GDT的该条目的段选择器（即索引为0并且TI标志设置为0的段选择器）被用作“空段选择器”。当段寄存器（CS 或 SS 寄存器除外）加载空选择器时，处理器不会生成异常。然而，当使用持有空选择器的段寄存器来访问内存时，它确实会生成异常。空选择器可用于初始化未使用的段寄存器。使用空段选择器加载 CS 或 SS 寄存器会导致生成一般保护异常 (#GP)。段选择器作为指针变量的一部分对应用程序可见，但选择器的值通常由链接编辑器或链接加载器而不是应用程序分配或修改。

### 段寄存器

![1695821259461](images/1695821259461.png)

为了减少地址转换时间和编码复杂性，处理器提供了用于保存最多 6 个段选择器的寄存器（见图）。每个段寄存器都支持特定类型的内存引用。实际上，要执行任何类型的程序，至少必须向代码段 (CS)、数据段 (DS) 和堆栈段 (SS) 寄存器加载有效的段选择器。处理器还提供三个附加数据段寄存器（ES、FS 和 GS），可用于为当前正在执行的程序（或任务）提供附加数据段。

对于要访问段的程序，该段的段选择器必须已加载到段寄存器之一中。因此，尽管系统可以定义数千个段，但只有 6 个可以立即使用。通过在程序执行期间将其段选择器加载到这些寄存器中，可以使其他段可用。

每个段寄存器都有一个“可见”部分和一个“隐藏”部分。 （隐藏部分有时称为“描述符高速缓存”或“影子寄存器”）当段选择器加载到段寄存器的可见部分时，处理器还会加载段寄存器的隐藏部分段选择器指向的段描述符中的基地址、段限制和访问控制信息。缓存在段寄存器（可见和隐藏）中的信息允许处理器转换地址，而无需花费额外的总线周期来从段描述符中读取基地址和限制。在多个处理器可以访问相同描述符表的系统中，当描述符表被修改时，软件负责重新加载段寄存器。如果不这样做，则在修改其内存驻留版本后，可能会使用缓存在段寄存器中的旧段描述符。

有两种加载指令用于加载段寄存器：

1. 直接加载指令，例如 MOV 、 POP 、 LDS 、 LES 、 LSS 、 LGS 和 LFS 指令。这些指令显式引用段寄存器。MOV指令还可用于将段寄存器的可见部分存储在通用寄存器中
2. 隐式加载指令，例如 CALL、JMP 和 RET 指令的远指针版本、SYSENTER 和 SYSEXIT 指令以及 IRET、INT n、INTO、INT3 和 INT1 指令。这些指令更改 CS 寄存器（有时还更改其他段寄存器）的内容，作为其操作的附带部分。

### 段描述子

段描述符是 GDT 或 LDT 中的数据结构，它为处理器提供段的大小和位置，以及访问控制和状态信息。段描述符通常由编译器、链接器、加载器或操作系统或执行程序创建，但不是应用程序。下图说明了所有类型的段描述符的通用描述符格式。

![1695821501518](images/1695821501518.png)

段描述符中的标志和字段如下。

#### Segment limit field（段限制字段）

指定段的大小。处理器将两个段限制字段放在一起形成一个 20 位值。处理器以两种方式之一解释段限制，具体取决于 G（粒度）标志的设置：

* 如果粒度标志为0，则段大小的范围可以从 1 字节到 1 MByte，以字节为增量。
* 如果设置了粒度标志，则段大小的范围可以从 4 KB 到 4 GB，以 4 KB 增量。

处理器以两种不同的方式使用段限制，具体取决于该段是向上扩展段还是向下扩展段。对于扩展段，逻辑地址中的偏移量范围可以从 0 到段限制。大于段限制的偏移量会生成一般保护异常（#GP，对于除 SS 之外的所有段）或堆栈错误异常（#SS，对于 SS 段）。对于向下扩展的段，段限制具有相反的功能；偏移量的范围可以从段限制加 1 到 FFFFFFFFH 或 FFFFH，具体取决于 B 标志的设置。小于或等于段限制的偏移量会生成一般保护异常或堆栈错误异常。减小展开段的段限制字段中的值会在段地址空间的底部而不是顶部分配新内存。

#### Base address fields（基址字段）

定义 4 GB 线性地址空间内段的字节 0 的位置。处理器将三个基地址字段放在一起形成一个 32 位值。段基地址应与 16 字节边界对齐。尽管不需要 16 字节对齐，但这种对齐允许程序通过在 16 字节边界上对齐代码和数据来最大限度地提高性能。

#### Type field（类型字段）

指示段或门类型，并指定可以对段进行访问的类型和增长方向。该字段的解释取决于描述符类型标志指定应用程序（代码或数据）描述符还是系统描述符。代码、数据和系统描述符的类型字段的编码是不同的。

#### S-描述符类型标志

指定段描述符是用于系统段（S 标志清零）还是代码或数据段（S 标志设置）。

#### DPL field（描述符特权级别字段）

指定段的权限级别。权限级别的范围为 0 到 3，其中 0 是最高权限级别。 DPL 用于控制对段的访问。

#### P-段存在标志

指示该段是否存在于内存中（设置）或不存在（清除）。如果清除该标志，则当指向段描述符的段选择器加载到段寄存器中时，处理器会生成段不存在异常 (#NP)。内存管理软件可以使用此标志来控制在给定时间哪些段实际加载到物理内存中。除了分页之外，它还提供了用于管理虚拟内存的控制。

#### D/B标志

根据段描述符是可执行代码段、向下扩展数据段还是堆栈段来执行不同的功能。 （对于 32 位代码和数据段，该标志应始终设置为 1；对于 16 位代码和数据段，该标志应始终设置为 0。）

#### G-粒度标志

确定段限制字段的缩放比例。当粒度标志为0时，段限制以字节为单位解释；当设置标志时，段限制以 4 KB 为单位进行解释。此标志不会影响基地址的粒度，它始终是字节粒度的。设置粒度标志后，在根据段限制检查偏移量时，不会测试偏移量的 12 个最低有效位。例如，当设置粒度标志时，限制为 0 会导致从 0 到 4095 的有效偏移量。

#### L-64位代码段标志

在 IA-32e 模式下，段描述符的第二个双字的位 21 指示代码段是否包含本机 64 位代码。值为 1 表示该代码段中的指令以 64 位模式执行。值为 0 表示该代码段中的指令以兼容模式执行。如果设置了 L 位，则必须清除 D 位。当不在 IA-32e 模式下或对于非代码段时，位 21 被保留并且应始终设置为 0。

#### Available and reserved bits（可用位和保留位）

段描述符的第二个双字的位 20 可供系统软件使用。

## 描述符的分类

### 代码段和数据段描述符

当段描述符中的 S（描述符类型）标志被设置时，该描述符用于代码段或数据段。然后，类型字段的最高位（段描述符的第二个双字的位 11）确定描述符是用于数据段（0）还是代码段（1）。

* 数据段描述符（Data segment Descriptor）：数据段描述符用于描述存储数据的内存段的属性和访问权限。它包含了段的起始地址、段的大小、访问权限、段的类型等信息。
* 代码段描述符（Code segment Descriptor）：代码段描述符用于描述存储可执行代码的内存段的属性和访问权限。它包含了段的起始地址、段的大小、访问权限、段的类型等信息。

对于数据段，类型字段的三个低位（位 8、9 和 10）被解释为已访问 (A)、可写 (W) 和扩展方向 (E)。有关代码段和数据段类型字段中位编码的说明如下图所示。数据段可以是只读段或读/写段，具体取决于写使能位的设置。

![1695822312255](images/1695822312255.png)

堆栈段是数据段，必须是读/写段。使用不可写数据段的段选择器加载 SS 寄存器会生成一般保护异常 (#GP)。如果需要动态改变堆栈段的大小，则堆栈段可以是向下扩展的数据段（设置了扩展方向标志）。在这里，动态更改段限制会导致堆栈空间添加到堆栈底部。如果堆栈段的大小旨在保持静态，则堆栈段可以是向上扩展或向下扩展类型。

访问位指示自上次操作系统或执行程序清除该位以来该段是否已被访问过。每当处理器将段的段选择器加载到段寄存器中时，假设包含段描述符的内存类型支持处理器写入，处理器就会设置该位。该位保持设置状态，直到明确清除为止。该位可用于虚拟内存管理和调试。

对于代码段，类型字段的三个低位被解释为已访问 (A)、读使能 (R) 和一致 (C)。代码段可以是只执行的，也可以是执行/读取的，具体取决于读使能位的设置。当常量或其他静态数据与指令代码一起放置在 ROM 中时，可能会使用执行/读取段。这里，可以通过使用带有 CS 覆盖前缀的指令或通过在数据段寄存器（DS、ES、FS 或 GS 寄存器）中加载代码段的段选择器来从代码段读取数据。在保护模式下，代码段不可写。

代码段可以是一致的，也可以是不一致的。将执行转移到特权更高的一致段允许执行在当前特权级别上继续。除非使用调用门或任务门，否则以不同权限级别传输到不合格段会导致一般保护异常 (#GP)。不访问受保护设施和某些类型异常（例如除法错误或溢出）处理程序的系统实用程序可以加载到一致的代码段中。需要保护其不受特权较低的程序和过程影响的实用程序应放置在不合格的代码段中。

所有数据段都是不一致的，这意味着它们不能被特权较低的程序访问。然而，与代码段不同的是，数据段可以由更高特权的程序访问，而无需使用特殊的访问门。

如果 GDT 或 LDT 中的段描述符放置在 ROM 中，则当软件或处理器尝试更新基于 ROM 的段描述符时，处理器可能会进入无限循环。为了防止这个问题，需要存放在ROM中的所有描述符的以访问位应该预先设置为置位状态。同时，删除尝试修改 ROM 中的段描述符的操作系统或执行代码。

### 系统描述符

当段描述符中的S（描述符类型）标志被清除时，该描述符类型是系统描述符。处理器可识别以下类型的系统描述符：

* 局部描述符表描述符（Local Descriptor-Table (LDT) segment descriptor）：局部描述符表描述符用于描述局部描述符表的属性和访问权限。局部描述符表是一种特殊的描述符表，用于存储其他描述符，如数据段描述符、代码段描述符等。
* 任务状态段描述符（Task-state segment (TSS) descriptor）：任务状态段描述符用于描述任务状态段的属性和访问权限。任务状态段是一种特殊的段，用于存储任务的状态信息，如寄存器的值、堆栈指针等。

* 调用门描述符（Call-gate descriptor）：调用门描述符用于描述调用门的属性和访问权限。调用门是一种特殊的门，用于实现不同特权级之间的过程调用。
* 中断门描述符（Interrupt-gate descriptor）：中断门描述符用于描述中断门的属性和访问权限。中断门是一种特殊的门，用于实现中断处理程序的调用。

* 陷阱门描述符（Trap-gate descriptor）：陷阱门描述符用于描述陷阱门的属性和访问权限。陷阱门是一种特殊的门，用于实现陷阱处理程序的调用。
* 任务门描述符（Task-gate descriptor）：任务门描述符用于描述任务门的属性和访问权限。任务门是一种特殊的门，用于实现任务的切换和调度。

这些描述符类型分为两类：系统段描述符和门描述符。系统段描述符指向系统段（LDT 和 TSS 段）。门描述符本身就是“门”，它保存指向代码段中过程入口点的指针（调用、中断和陷阱门），或者保存 TSS（任务门）的段选择器。

下图显示了系统段描述符和门描述符的类型字段的编码。

![1695822973726](images/1695822973726.png)
