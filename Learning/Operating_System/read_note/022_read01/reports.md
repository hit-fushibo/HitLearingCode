# x86 系统架构概览

## 系统级体系结构概览

![img](.\images\1.png "系统级寄存器与数据结构")

如上图所示，系统级体系结构由一组寄存器、数据结构和指令组成，旨在支持基本的系统级操作，如内存管理、中断和异常处理、任务管理以及对多个处理器的控制。

下面将对

- Global and Local Descriptor Tables
- System Segments, Segment Descriptors, and Gates
- Task-State Segments and Task Gates
- Interrupt and Exception Handling
- Memory Management
- System Registers

进行介绍。

### Global and Local Descriptor Tables（全局和局部描述符表）

在保护模式下操作时，所有内存访问都通过全局描述符表（GDT）或可选的本地描述符表，如图 2-1 所示。这些表包含称为段描述符的条目。段描述符提供段的基本地址以及访问权限、类型和使用信息。

每个段描述符都有一个关联的段选择器。段选择器为使用它的软件提供了 GDT 或 LDT 的索引（其关联段描述符的偏移量）、全局/局部标志（确定选择器是指向 GDT 还是 LDT）以及访问权限信息。

要访问段中的字节，必须提供段选择器和偏移量。段选择器提供对段（在 GDT 或 LDT 中）的段描述符的访问。从段描述符中，处理器获得线性地址空间中段的基地址。然后，偏移量提供字节相对于基地址的位置。该机制可用于访问任何有效的代码、数据或堆栈段，前提是可以从处理器运行的当前特权级别 (CPL) 访问该段。 CPL 被定义为当前执行代码段的保护级别。

为了简单起见，许多段选择器都显示为指向段的直接指针。然而，从段选择器到其关联段的实际路径始终是通过 GDT 或 LDT。

GDT 基址的线性地址包含在 GDT 寄存器（GDTR）中； LDT 的线性地址包含在 LDT 寄存器（LDTR）中。

### System Segments, Segment Descriptors, and Gates（系统段、段描述符和门）

除了构成程序或过程的执行环境的代码、数据和堆栈段之外，该体系结构还定义了两个系统段：任务状态段（TSS）和 LDT。 GDT 不被视为段，因为它不是通过段选择器和段描述符来访问的。 TSS 和 LDT 具有为其定义的段描述符。

该架构还定义了一组称为门的特殊描述符（调用门、中断门、陷阱门和任务门）。它们为系统过程和处理程序提供了受保护的网关，这些系统过程和处理程序可以在与应用程序和大多数过程不同的特权级别上运行。例如，对调用门的 CALL 可以提供对代码段中的过程的访问，该代码段的特权级别与当前代码段相同或在数值上较低（更高特权）。为了通过调用门访问过程，调用过程 1 为调用门提供选择器。然后，处理器对调用门执行访问权限检查，将 CPL 与调用门的特权级别以及调用门指向的目标代码段进行比较。

如果允许访问目标代码段，处理器将获取目标代码段的段选择器以及从调用门到该代码段的偏移量。如果调用需要更改特权级别，处理器也会切换到目标特权级别的堆栈。新堆栈的段选择器是从当前正在运行的任务的 TSS 中获取的。门还有助于 16 位和 32 位代码段之间的转换，反之亦然。

### Task-State Segments and Task Gates（任务状态段和任务门）

TSS 定义了任务执行环境的状态。它包括通用寄存器、段寄存器、EFLAGS 寄存器、EIP 寄存器以及带有用于三个堆栈段（每个特权级别一个堆栈）的堆栈指针的段选择器的状态。 TSS 还包括与任务关联的 LDT 的段选择器以及分页结构层次结构的基地址。

保护模式下的所有程序执行都发生在任务（称为当前任务）的上下文中。当前任务的 TSS 段选择器存储在任务寄存器中。切换到任务最简单的方法是调用或跳转到新任务。这里，新任务的 TSS 的段选择器在 CALL 或 JMP 指令中给出。在切换任务时，处理器执行以下操作：

1. 将当前任务的状态存储在当前 TSS 中。
2. 将新任务的段选择器加载到任务寄存器中。
3. 通过 GDT 中的段描述符访问新的 TSS。
4. 将新任务的状态从新 TSS 加载到通用寄存器、段寄存器、LDTR、控制寄存器 CR3（分页结构层次结构的基地址）、EFLAGS 寄存器和 EIP 寄存器中。
5. 开始执行新任务。

还可以通过任务门访问任务。任务门类似于调用门，不同之处在于它提供对 TSS 而不是代码段的访问（通过段选择器）。

### Interrupt and Exception Handling（中断和异常处理）

外部中断、软件中断和异常都是通过中断描述符表（IDT）来处理的。IDT 存储门描述符的集合，提供对中断和异常处理程序的访问。与 GDT 一样，IDT 也不是段。 IDT 基址的线性地址包含在 IDT 寄存器 (IDTR) 中。IDT 中的门描述符可以是中断、陷阱或任务门描述符。为了访问中断或异常处理程序，处理器首先通过 INT n、INTO、INT3、INT1 或 BOUND 指令从内部硬件、外部中断控制器或软件接收中断向量。中断向量提供了 IDT 的索引。如果所选择的门描述符是中断门或陷阱门，则以与通过调用门调用过程类似的方式访问关联的处理程序过程。如果描述符是任务门，则通过任务切换来访问处理程序。

### Memory Management（内存管理）

系统架构支持内存的直接物理寻址或虚拟内存（通过分页）。当使用物理寻址时，线性地址被视为物理地址。使用分页时：所有代码、数据、堆栈和系统段（包括 GDT 和 IDT）都可以进行分页，并且仅将最近访问的页面保存在物理内存中。物理内存中页（有时称为页框）的位置包含在分页结构中。这些结构驻留在物理内存中。分页结构层次结构的基本物理地址包含在控制寄存器 CR3 中。分页结构中的条目确定页框基址的物理地址、访问权限和内存管理信息。为了使用这种分页机制，线性地址被分成几部分。这些部分提供了分页结构和页框的单独偏移。系统可以具有单个或多个分页结构层次结构。

### System Registers（系统寄存器）

为了帮助初始化处理器和控制系统操作，系统架构在 EFLAGS 寄存器和几个系统寄存器中提供了系统标志：

- EFLAGS 寄存器中的系统标志和 IOPL 字段控制任务和模式切换、中断处理、指令跟踪和访问权限。
- 控制寄存器（CR0、CR2、CR3 和 CR4）包含用于控制系统级操作的各种标志和数据字段。这些寄存器中的其他标志用于指示操作系统或执行程序内对特定处理器功能的支持。
- 调试寄存器（图中未显示）允许设置断点以用于调试程序和系统软件。
- GDTR、LDTR 和 IDTR 寄存器包含其各自表的线性地址和大小。
- 任务寄存器包含当前任务的 TSS 的线性地址和大小。
- 模型特定寄存器（图中未显示）。模型特定寄存器 (MSR) 是一组主要可供操作系统或执行程序（即在特权级别 0 运行的代码）使用的寄存器。这些寄存器控制调试扩展、性能监控计数器、机器检查架构和内存类型范围 (MTRR) 等项目。

## 实模式和保护模式转换

x86 架构支持实模式（Real-address mode）和保护模式（Protected mode）两种操作模式。

- 保护模式：处理器的本机操作模式。它提供了一组丰富的架构特性、灵活性、高性能以及对现有软件库的向后兼容性。
- 实模式：提供了 Intel 8086 处理器的编程环境，并具有一些扩展功能（例如切换到保护模式或系统管理模式的能力）。

更一般地，实模式是早期的模式，提供了对物理内存的直接访问，但没有内存保护和多任务支持。保护模式是一种更先进的模式，提供了内存保护、虚拟内存、多任务等功能。

要从实模式切换为保护模式，需要进行以下更改：

1. 设置 GDT 和 IDT：首先，需要定义和加载全局描述符表（GDT）和中断描述符表（IDT），以便在保护模式下正确处理段和中断。
2. 修改控制寄存器（CR0）：需要将控制寄存器（CR0）的一些位设置为保护模式所需的值。具体来说，需要将 CR0 的第 0 位（PE 位）设置为 1，表示启用保护模式。
3. 加载段选择子：在进入保护模式后，需要修改段选择子，以加载保护模式下的正确段描述符。段选择子是一个 16 位的值，包含了段的索引和特权级别等信息。
4. 设置页表：保护模式下的内存管理是通过分页机制实现的。因此，需要定义和加载页表，以实现虚拟内存管理。页表是一种数据结构，用于将虚拟地址映射到物理地址。
5. 切换堆栈：在保护模式下，堆栈的使用方式可能与实模式下不同。因此，需要切换堆栈，以便在保护模式下正确处理函数调用和中断。

而要从保护模式切换为实模式，需要进行以下更改：

1. 清除分页机制：在保护模式下，使用了分页机制来管理内存。因此，需要禁用分页机制，将控制寄存器（CR0）的第 31 位（PG 位）设置为 0，以禁用分页。
2. 清除段选择子：在保护模式下，使用了段描述符来访问内存。为了切换回实模式，需要将段选择子设置为实模式下的默认值。实模式下的段选择子只包含段的偏移地址，没有特权级别等其他信息。
3. 清除 GDT 和 IDT：在保护模式下，使用了全局描述符表（GDT）和中断描述符表（IDT）来管理段和中断。为了切换回实模式，需要将 GDT 和 IDT 设置为实模式下的默认值，或者完全禁用它们。
4. 清除页表：在保护模式下，使用了页表来管理虚拟内存。为了切换回实模式，需要禁用页表，或者将页表设置为实模式下的默认值。
5. 切换堆栈：在保护模式下，堆栈的使用方式可能与实模式下不同。为了切换回实模式，需要切换回实模式下的堆栈，以便在实模式下正确处理函数调用和中断。

## 80x86 系统指令寄存器

为了协助处理器执行初始化和控制系统操作，80X86 提供了一个标志寄存器 EFLAGS 和几个系统寄存器。除了一些通用状态标志外，EFLAGFS 中还包含几个系统标志用于控制任务切换、中断处理、指令跟踪以及访问权限。系统寄存器用于内存管理和控制处理器操作，含有分段和分页处理机制系统表的基地址、控制处理器操作的比特标志位。

### 标志寄存器 EFLAGS

![EFLAGS](.\images\2.png "EFLAGS")

如上图所示，标志寄存器 EFLAGS 中的系统标志和 IOPL 字段用于控制 IO 访问、可屏蔽硬件中断、调试、任务切换以及虚拟-8086 模式。通常只允许操作系统代码有权修改这些标志。EFLAGS 中的其他标志是一些通用标志（进位 CF、奇偶 PF、辅助进位 AF、零标志 ZF、负号 SF、方向 DF、溢出 OF)。这里我们仅对 EFLAGS 中的系统标志进行说明。

| 系统标志位 | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| TF         | 位 8 是跟踪标志（Trap Flag)。当设置该位时可为调试操作启动单步执行方式;复位时则禁止单步执行。<br />在单步执行方式下，处理器会在每个指令执行之后产生一个调试异常，这样我们就可以观察执行程序<br />在执行每条指令后的状态。如果程序使用 POPF,POPFD 或 IRET 指令设置了 TF 标志那么在随后指令之后<br />处理器就会产生一个调试异常。                                                                                                         |
| IOPL       | 位 13-12 是 I/O 特权级（I/O Privilege Level）字段。该字段指明当前运行程序或任务的 I/O 特权级 IOPL。<br />当前运行程序或任务的 CPL 必须小于等于这个 IOPL 才能访问 I/O 地址空间。只有当 CPL 为特权级 0 时，程<br />序才可以使用 POPF 或 IRET 指令修改这个字段。IOPL 也是控制对 IF 标志修改的机制之一。                                                                                                                                   |
| NT         | 位 14 是嵌套任务标志（Nested Task)。它控制着被中断任务和调用任务之间的链接关系。在使用 CALL<br />指令、中断或异常执行任务调用时，处理器会设置该标志。在通过使用 IRET 指令从一个任务返回时，处<br />理器会检查并修改这个 NT 标志。使用 POPF/POPFD 指令也可以修改这个标志，但是在应用程序中改变<br />这个标志的状态会产生不可意料的异常。                                                                                                |
| RF         | 位 16 是恢复标志（Resume Flag)。该标志用于控制处理器对断点指令的响应。当设置时，这个标志会<br />临时禁止断点指令产生的调试异常；当该标志复位时，则断点指令将会产生异常。RF 标志的主要功能是<br />允许在调试异常之后重新执行一条指令。当调试软件使用 IRETD 指令返回被中断程序之前，需要设置堆<br />栈上 EFLAGS 内容中的 RF 标志，以防止指令断点造成另一个异常。处理器会在指令返回之后自动地清除<br />该标志，从而再次允许指令断点异常。 |
| VM         | 位 17 是虚拟-8086 方式（Virtual-8086 Mode）标志。当设置该标志时，就开启虚拟-8086 方式：当复<br />位该标志时，则回到保护模式。                                                                                                                                                                                                                                                                                                          |

### 内存管理寄存器

![内存管理寄存器](images/3.png "内存管理寄存器")

如上图，处理器提供了 4 个内仔管理寄存器（GDTR、LDTR、IDTR 和 TR)，用于指定分段内存管理所使用的系统表的基地址。

GDTR、LDTR、IDTR 和 TR 都是段基址寄存器，这些段中含有分段机制的重要信息表。GDTR、IDTR 和 LDTR 用于寻址存放描述符表的段。TR 用于寻址一个特殊的任务状态段 TSS（Task State Segment)。TSS 段中包含着当前执行任务的重要信息。

- GDTR 寄存器中用于存放全局描述符表 GDT 的 32 位线性基地址和 16 位表长度值。基地址指定 GDT 表中字节 0 在线性地址空间中的地址，表长度指明 GDT 表的字节长度值。指令 LGDT 和 SGDT 分别用于加载和保存 GDTR 寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为 0，而长度值被设置成 0xFFFF。在保护模式初始化过程中必须给 GDTR 加载一个新值。
- 与 GDTR 的作用类似, IDTR 寄存器用于存放中断描述符表 IDT 的 32 位线性基地址和 16 位表长度值指令 LIDT 和 SIDT 分别用于加载和保存 IDTR 寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为 0，而长度值被设置成 0xFFFFa。
- LDTR 寄存器中用于存放局部描述符表 LDT 的 32 位线性基地址、16 位段限长和描述符属性值。指令 LLDT 和 SLDT 分别用于加载和保存 LDTR 寄存器的段描述符部分。包含 LDT 表的段必须在 GDT 表中有一个段描述符项。当使用 LLDT 指令把含有 LDT 表段的选择符加载进 LDTR 时，LDT 段描述符的段基地址、段限长度以及描述符属性会被自动地加载到 LDTR 中。当进行任务切换时，处理器会把新任务 LDT 的段选择符和段描述符自动地加载进 LDTR 中。在机器加电或处理器复位后，段选择符和基地址被默认地设置为 0,而段长度被设置成 0xFFFF。
- TR 寄存器用于存放当前任务 TSS 段的 16 位段选择符、32 位基地址、16 位段长度和描述符属性值。它引用 GDT 表中的一个 TSS 类型的描述符。指令 LTR 和 STR 分别用于加载和保存 TR 寄存器的段选择符部分。当使用 LTR 指令把选择符加载进任务寄存器时，TSS 描述符中的段基地址、段限长度以及描述符属性会被自动地加载到任务寄存器中。当执行任务切换时，处理器会把新任务 TSS 的段选择符和段描述符自动地加载进任务寄存器 TR 中。

### 控制寄存器

![控制寄存器](images/4.png "控制寄存器")

如上图，控制寄存器（CR0、CR1、CR2 和 CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。CRO 中含有控制处理器操作模式和状态的系统控制标志；CRI 保留不用:CR2 含有导致页错误的线性地址。CR3 中含有页目录表物理内存基地址,因此该寄存器也被称为页目录录基地址寄存器 PDBR(Page-Directory Base address Register ）。

#### CR0

CR0 的 4 个比特位：扩展类型位 ET、任务切换位 TS、仿真位 EM 和数学存在位 MP 用于控制 80X86 浮点（数学）协处理器的操作。CR0 的 ET 位（标志）用于选择与协处理器进行通信所使用的协议，即指明系统中使用的是 80387 还是 80287 协处理器。TS、MP 和 EM 位用于确定浮点指令或 WAIT 指令是否应该产生一个设备不存在 DNA（Device Not Available）异常。这个异常可用来仅为使用浮点运算的任务保存和恢复浮点寄存器。对于没有使用浮点运算的任务，这样做可以加快它们之间的切换操作。

CR0 中还有 4 个保护控制位，如下表。

| 保护控制位 | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| :--------: | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     PE     | CR0 的位 0 是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；<br />当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若<br />要启用分页机制，那么 PE 和 PG 标志都要置位。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|     PG     | CR0 的位 31 是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则<br />禁止分页机制此时所有线性地址等同于物理地址。在开启这个标志之前必须己经或<br />者同时开启 PE 标志。即若要启用分页机制，那么 PE 和 PG 标志都要置位。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
|     WP     | 对于 Intel 80486 或以上的 CPU,CR0 的位 16 是写保护（Write Proctect）标志。当<br />设置该标志时处理器会禁止超级用户程序（例如特权级 0 的程序）向用户级只读页<br />面执行写操作；当该位复位时则反之。该标志有利于 UNIX 类操作系统在创建进程<br />时实现写时复制（Copy on Write）技术。                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|     NE     | 对于 Intel 80486 或以上的 CPU, CR0 的位 5 是协处理器错误（Numeric Error）标志。<br />当设置该标志时，就启用了 X87 协处理器错误的内部报告机制；若复位该标志，那么<br />就使用 PC 机形式的 X87 协处理器错误报告机制。当 NE 为复位状态并且 CPU 的 IGNNE<br />输入引脚有信号时，那么数学协处理器 X87 错误将被忽略。当 NE 为复位状态并且 CPU<br />的 IGNNE 输入引脚无信号时，那么非屏蔽的数学协处理器 X87 错误将导致处理器通过<br />FERR 引脚在外部产生一个中断,并且在执行下一个等待形式浮点指令或 WAIT/FWAIT<br />指令之前立刻停止指令执行。CPU 的 FERR 引脚用于仿真外部协处理器 80387 的 <br />ERROR 引脚，因此通常连接到中断控制器输入请求引脚上。NE 标志、IGNNE 引<br />脚和 FERR 引脚用于利用外部逻辑来实现 PC 机形式的外部错误报告机制。 |

#### CR2 和 CR3

CR2 和 CR3 用于分页机制。CR3 含有存放页目录表页面的物理地址，因此 CR3 也被称为 PDBR。因为页目录表页面是页对齐的，所以该寄存器只有高 20 位是有效的。而低 12 位保留供更高级处理器使用，因此在往 CR3 中加载一个新值时低 12 位必须设置为 0。

使用 MOV 指令加载 CR3 时具有让页高速缓冲无效的副作用。为了减少地址转换所要求的总线周期数量，最近访问的页目录和页表会被存放在处理器的页高速缓冲器件中，该缓冲器件被称为转换查找缓冲区 TLB（TranslationLookaside Buffer)。只有当 TLB 中不包含要求的页表项时才会使用额外的总线周期从内存中读取页表项。

即使 CR0 中的 PG 位处于复位状态（PG=0)，我们也能先加载 CR3。以允许对分页机制进行初始化当切换任务时，CR3 的内容也会随之改变。但是如果新任务的 CR3 值与原任务的一样，处理器就无需刷新页高速缓冲。这样共享页表的任务可以执行得更快。
CR2 用于出现页异常时报告出错信息。在报告页异常时，处理器会把引起异常的线性地址存放在 CR2 中。因此操作系统中的页异常处理程序可以通过检查 CR2 的内容来确定线性地址空间中哪一个页面引发了异常。

## 系统指令

系统指令用于处理系统级功能。大多数系统指令只能由处于特权级 0 的操作系统软件执行，其余一些指令可以在任何特权级上执行。下表列出一些常见的系统指令。

| 指令 | 是否受保护 | 说明                                                                             |
| :--: | :--------: | :------------------------------------------------------------------------------- |
| LGDT |     是     | 加载全局描述符表寄存器 GDTR。把 GDT 表的基地址和长度从内存加载到 GDTR 中。       |
| SGDT |     否     | 保存全局描述符表寄存器 GDTR。把 GDTR 中 IDT 表的基地址和长度保存到内存中         |
| LIDT |     是     | 加载中断描述符表寄存器 IDTR。把 IDT 表的基地址和长度从内存加载到 IDTR 中。       |
| SIDT |     否     | 保存中断描述符表寄存器 IDTR。把 IDTR 中 IDT 表的基地址和长度保存到内存中         |
| LLDT |     是     | 加载局部描述符表寄存器 LDTR。从内存加载 LDT 段选择符和段描述符到 LDTR 寄存器中。 |
| SLDT |     否     | 保存局部描述符表奇存器 LDTR。把 LDTR 中的 LDT 段选择符保存到内存或通用寄存器中   |
| LTR |     是     | 加载任务寄存器 TR。把 TSS 段选择符（和段描述符）加载到任务寄存器中               |
| STR |     否     | 保存任务寄存器 TR。把 TR 中当前任务 TSS 段选择符保存到内存或同通用寄存器中。     |
